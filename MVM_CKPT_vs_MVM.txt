/include/ckpt_setup.h
/src/_ckpt_setup.c
Introduzione di:
	- void *tls_setup();
La funzione void *tls_setup(), un utility che permette di allocare una area di memoria di 64 byte, 
o 128 byte nel caso MOD sia 512, e assegnarla al segmento GS.

/patches/patches.c
Introduzione delle funzioni:
    - void ckpt_patch(instruction_record *actual_instruction, patch *actual_patch)
    - void save_regs_tls(patch *actual_patch)
ckpt_path permette di creare un'istruzione lea in modo da caricare nel registro rax l'indirizzo di memoria su cui sta 
operando l'operazione di mov patchata.
save_regs_tls salva in actual_patch il codice bianrio equivalente a:
    mov %rax, %gs:0
    mov %rbx, %gs:8
    mov %rcx, %gs:16
nel caso 64 bit.
Per i casi 128 bit e 256 bit vengono aggiunti rispettivamente l'istruzione movdqu %xmm1, %gs:24 o vmovdqu %ymm1, %gs:24.

/src/_asm_patches.S 
Alla label ckpt_assembly viene introdotto il codice asm che effetua il checkpoint per le quattro modalità (64 bit, 128 bit, 256 bit, 512 bit).

/src/_elf_parse.c 
Di seguito le modifiche o aggiunte linea per linea.

15 #if CKPT
16 void ckpt_patch(instruction_record *, patch *);
17 void save_regs_tls(patch *);
18 #endif

40 #if CKPT
41 	if (the_record->type == 'l') { //avoid audit of load instruction in ckpt
42 		return;
43 	}
44 #endif
Nel caso CKPT si evita l'audit nel caso delle operazione di load.

116 #if CKPT
117     uint64_t ckpt_code = (uint64_t)ckpt_assembly;
118 #if MOD == 64
119     int ckpt_code_size = 0xbe; // this is taken from the compiled version of the src/_asm_patch.S file
120 #elif MOD == 128
121     int ckpt_code_size = 0xd9;
122 #elif MOD == 256
123     int ckpt_code_size = 0xd4; 
124 #else
125     int ckpt_code_size = 0xe3;
126 #endif
127 #endif
Definisce il codice di checkpoint e la sua size nelle varie modalità.

132 #if CKPT
133        if (instructions[i].type == 'l')
134             continue; // avoid patch of load instruction
135 #endif
Evita la patch delle istruzioni di load.

183 #ifdef CKPT
184 #if MOD == 64
185         memset((char *)(patches[i].code), 0x90, 37 + ckpt_code_size);
186         save_regs_tls(&patches[i]);
187         patches[i].code = patches[i].code + 27; // 27 is the size of the instructions to save the regs in gs
188 #elif MOD == 128 || MOD == 256
189         memset((char *)(patches[i].code), 0x90, 47 + ckpt_code_size);
190         save_regs_tls(&patches[i]);
191         patches[i].code = patches[i].code + 37; // 37 is the size of the instructions to save the regs in gs
192 #else
193         memset((char *)(patches[i].code), 0x90, 49 + ckpt_code_size);
194         save_regs_tls(&patches[i]);
195         patches[i].code = patches[i].code + 39;
196 #endif
197         ckpt_patch(&instructions[i], &patches[i]);
198         patches[i].code = patches[i].code + 10; // 10 is the mazimum size of the lea instruction
199         memcpy((char *)(patches[i].code), (char *)(ckpt_code), ckpt_code_size);
200         patches[i].code = patches[i].code + ckpt_code_size;
201 #endif
Chiamate a save_rgs_tls e ckpt_path prima del salvataggio del codice di checkpointing.

206 #ifdef CKPT
207         // move again at the begin of the block of instructions forming the patch
208         // NOTE: you will need to have patches[i].code point again to patches[i].block before proceeding with the
209         // following if/else
210 #if MOD == 64
211         patches[i].code = patches[i].code - 37 - ckpt_code_size;
212 #elif MOD == 128 || MOD == 256
213         patches[i].code = patches[i].code - 47 - ckpt_code_size;
214 #else
215         patches[i].code = patches[i].code - 49 - ckpt_code_size;
216 #endif
217 #endif
Riallineamento all'inizio del codice della patch

290 #ifdef CKPT
293 #if MOD == 64
294         patches[i].code = patches[i].code + 37 + ckpt_code_size;
295 #elif MOD == 128 || MOD == 256
296         patches[i].code = patches[i].code + 47 + ckpt_code_size;
297 #else
298         patches[i].code = patches[i].code + 49 + ckpt_code_size;
299 #endif
300 #endif
patches[i].code deve puntare all'istruzione originale quindi si proccede a puntare al termine della patch.

356 #if CKPT
357         if (instructions[i].type == 'l')
358             continue; // avoid apply patch to load instructions
359 #endif
Nella funzione void apply_patches(void) si evita l'applicazione delle patch alle istruzioni di load.

Makefile
TARGET_FUNCTIONS="<test_checkpoint>"

ADDITIONAL_FLAGS = -O3 -DCKPT -DAPPLY_PATCHES #-DVERBOSE
-DCKPT invece di -DASM_PREAMBLE

#CKPT FLAGS
ALLOCATOR_AREA_SIZE=0x100000UL
WRITES=950
READS=50
MOD=64
CF=0
Flag inseriti a supporto delle operazioni di test.

compile-and-link: movm
	export C_INCLUDE_PATH=$(PWD)/include; cd $(APP) ; make ALLOCATOR_AREA_SIZE=$(ALLOCATOR_AREA_SIZE) MOD=$(MOD) WRITES=$(WRITES) READS=$(READS) CF=$(CF) ; gcc $(APP_OBJ) $(LIB)/movm.o -o $(EXECUTABLE) $(SECURITY_FLAGS) $(ADDITIONAL_FLAGS) $(LIBS) -Xlinker --wrap=main
	objdump -Dw $(EXECUTABLE) > $(DISASSEMBLY)

make di $(APP) con i flag ALLOCATOR_AREA_SIZE MOD WRITES READS CF

checks:
	@if [ -d $(APP) ]; then echo ""; else echo "application directory does not exist" ; exit 1; fi
	@./scripts/file-existence.sh $(APP) $(TARGET_MODULES)
	@echo "PLEASE for any compiling error run 'make restore-files'\n"

	@if [ ! -d $(OBJ) ]; then mkdir -p $(OBJ); fi
	@if [ ! -d $(LIB) ]; then mkdir -p $(LIB); fi

Verifice e creazione in caso di assenza delle directory $(OBJ) e $(LIB)

asm-patch:
	cd ./src; gcc _asm_patches.S -c -I$(INCLUDE) $(SECURITY_FLAGS) $(ADDITIONAL_FLAGS) -DALLOCATOR_AREA_SIZE=$(ALLOCATOR_AREA_SIZE) -DMOD=$(MOD) -o $(OBJ)/_asm_patches.o
	objdump -Dw $(OBJ)/_asm_patches.o > $(TEMP)/disassembly_asm_patch 

Introduzione dei flag ALLOCATOR_AREA_SIZE e MOD in fase di compilazione. Disassemblaggio di _asm_patch.o per facilitare l'acquisizione della size di ckpt_assempbly.

patch:
	cd ./patches; gcc patches.c -c -I$(INCLUDE) $(THE_VM) $(UDTEMPDIR) $(UDTEMPFILE) $(UDTEMPOBJ) $(SECURITY_FLAGS) $(ADDITIONAL_FLAGS) -DMOD=$(MOD) -o $(OBJ)/_patches.o
#please rember to insert whatever Makefile in the user-defined directory
	cd $(USER_DEFINED); make

Introduzione del flag MOD per la compilazione di patches.c .

movm: base head startup asm-patch patch ckpt
	cd ./src; gcc _elf_parse.c -c $(TEMPDIR) $(TEMPFILE) $(DISASSEMBLY_FILE) $(TEMPOBJ) $(TF) $(THE_VM) -I$(INCLUDE) $(SECURITY_FLAGS) $(ADDITIONAL_FLAGS) -DMOD=$(MOD) -o $(OBJ)/_elf_parse.o
	cd $(OBJ) ; ld -i *.o -o $(LIB)/movm.o

Introduzione del flag MOD per la compilazione di _elf_parse.c .

ckpt:
	cd ./src; gcc _ckpt_setup.c -c -I$(INCLUDE) $(SECURITY_FLAGS) $(ADDITIONAL_FLAGS) -DMOD=$(MOD) -o $(OBJ)/_ckpt_setup.o

Compilazione di ckpt_setup.c
